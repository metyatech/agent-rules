## 設計原則・アーキテクチャ

### SOLID原則

#### 適用レベルの調整

SOLID原則は「コンテキスト」に応じて適用レベルを調整する。究極まで適用すると読みにくくなるため、「変更/追加が想定される責務」「追加が想定される機能」を1単位として設計する。

##### 徹底適用すべきコンテキスト

以下の条件を満たす場合は、SOLID原則を徹底的に適用し、責務を極限まで分離し、拡張ポイントを明示的に設ける：

- 外部から柔軟に使われることを想定するもの（プラグイン・モジュール・公開API・インターフェース）
- 外部利用者向けのドキュメントを提供する状況

##### 相対的に判断するコンテキスト

内部実装やアプリケーション固有のコードでは、以下を基準に適用レベルを判断する：

- 近い将来に変更/拡張が予想される箇所は責務を分離
- 安定していて変更が予想されない箇所は簡潔さを優先
- テスト容易性が必要な箇所はインターフェースで分離

#### SRP（単一責任原則）

クラスは「変更される理由」を1つだけ持つようにする。複数の責務を持つクラスを発見した場合は、以下のパターンで分離を検討する：

| パターン     | 用途                                     |
| ------------ | ---------------------------------------- |
| Strategy     | アルゴリズムの選択を分離                 |
| Factory      | オブジェクト生成を分離                   |
| Component    | 機能を独立したコンポーネントに分離       |
| Orchestrator | 処理の流れ（オーケストレーション）を分離 |

#### OCP（開放閉鎖原則）

拡張に対して開いており、修正に対して閉じている設計を目指す。ただし、すべての箇所に拡張ポイントを設けることは冗長なため、「将来拡張が想定される箇所」を見極めて適用する。

#### ISP（インターフェース分離の原則）

クライアントが使用しないメソッドへの依存を強制しない。大きなインターフェースは、クライアントのニーズに応じて小さなインターフェースに分割する。

#### DIP（依存性逆転の原則）

上位モジュールは下位モジュールに依存せず、両者は抽象に依存する。具象クラスへの直接依存を避け、インターフェース（UInterface、純粋仮想クラス）を経由して依存注入可能にする。

### レイヤー設計

#### 依存関係の方向

実装時はレイヤー（抽象度）を意識し、依存関係が適切な方向になるよう設計する：

- 上位レイヤー（ビジネスロジック）は下位レイヤー（インフラ・ユーティリティ）に依存しない
- 両者は抽象（インターフェース）に依存する
- 具象への依存は末端（エントリポイント・ファクトリ）に限定する

#### 汎用的な実装を心がける

機能を実装する際は、できるだけ汎用的・再利用可能な形で設計する。特定のユースケースに密結合した実装を避け、抽象化されたインターフェースを通じて利用できるようにする。

#### 汎用性に応じた配置先

実装の汎用性に応じて、適切な配置先を選択する：

| 汎用性                     | 配置先                   | 例                               |
| -------------------------- | ------------------------ | -------------------------------- |
| UE全般で使える             | 独立したプラグイン       | 汎用ユーティリティ、共通インフラ |
| このプロジェクト内で汎用的 | プロジェクトのモジュール | プロジェクト共通の基盤機能       |
| 特定機能に固有             | その機能のモジュール内   | 機能固有のロジック               |

### プラグイン/モジュール設計

#### 機能ごとの分離

プラグインやモジュールは機能ごとに分離する。複数の異なる機能を1つのプラグイン/モジュールに混在させない。

#### インターフェースの独立

インターフェースは具象型に依存しない。インターフェースを定義するプラグイン/モジュールは、実装プラグイン/モジュールとは別に作成する。

| 種類             | 命名規則      | 例                       |
| ---------------- | ------------- | ------------------------ |
| インターフェース | 〇〇Interface | AssetDownloaderInterface |
| 実装             | 〇〇          | RuntimeAssetDownloader   |

これにより、利用者はインターフェースプラグインのみに依存し、実装の差し替えが容易になる。

#### テストモジュールの配置

テストは対象の実装プラグイン/モジュール内に配置するが、実装とは別のモジュールとして分離する。

```
Plugins/
  MyFeature/
    Source/
      MyFeature/        # 実装モジュール
        Private/
        Public/
        MyFeature.Build.cs
      MyFeatureTests/   # テストモジュール
        Private/
        MyFeatureTests.Build.cs
```

### アーキテクチャ

#### 継承より合成

共通機能は UActorComponent へ分離し、過度な継承階層を避ける。

#### インターフェース優先

動的キャスト濫用を避け、UInterface/インターフェース経由で疎結合化する。ポリモーフィズムが必要な場合は、仮想関数/インターフェースをデフォルトとして優先する。

#### インターフェース（C++ 純粋抽象）

非 UObject の C++ インターフェース（純粋仮想クラス）は「値として扱わない」ことを明示するため、コピー/ムーブを `delete` し、デフォルトコンストラクタは `protected` に置く（デストラクタは `public virtual`）。

#### 依存注入

可換/テスタブルな箇所はインターフェース＋ファクトリで依存注入可能にし、テスト差し替え可能にする。サービスロケータを使う場合はスコープを限定し、グローバル化しない。

依存注入や API 引数/戻り値で null を想定しない場合は、参照型（TObjectRef、TSharedRef、C++参照など）を用いて非nullを型システムで表現する。値が存在しないことがあり得る場合は TOptional、TUniquePtr、TSharedPtr で表現する。生ポインタは極力避ける。

#### 遅延取得

フレームワーク依存のリソースは初期化時ではなく、実使用時に遅延取得する（先読み最適化より可読性/安全性を優先）。

#### コンポーネント一元化

複数の分散したコンポーネントは統合管理システムで一元化し、保守性と一貫性を向上させる。

#### Subsystem回避

新規にグローバルシングルトン/グローバル変数/プロジェクト独自 Subsystem（`UGameInstanceSubsystem` 等を継承した独自クラス）を追加することは可能な限り避ける。共有状態が必要な場合は、所有者と寿命が明確なオブジェクトへ閉じ込める。

Engine/公式プラグインが提供する既存 Subsystem 実装を利用することは許容する。ただし Subsystem をサービスロケータとして扱わない。

### デザインパターン

#### ファクトリパターン

オブジェクト生成を分離する必要がある場合は以下を使い分ける：

| パターン         | 用途                                         |
| ---------------- | -------------------------------------------- |
| Simple Factory   | 生成ロジックが単純で拡張性不要な場合         |
| Factory Method   | サブクラスに生成を委譲する場合               |
| Abstract Factory | 関連するオブジェクト群を一貫して生成する場合 |

UE では NewObject/SpawnActor に追加の初期化が必要な場合にファクトリを導入する。

#### ユーティリティ関数の禁止

新規に「Utils」的な雑多な namespace 関数を増やすことは避ける。外部依存（I/O・エンジン・時刻・乱数など）を持つ共通処理は、クラスとして設計し、インターフェース経由で依存注入可能にする。純粋で決定的な小さな処理は、翻訳単位内の `static`/無名 namespace 関数、または責務が明確な namespace 関数として許容する。既存のフレームワーク提供ユーティリティ（`FMath`、`FString` など）の使用は許容する。

### 抽象化

#### 抽象化レベルの一貫性

1つの関数内では抽象化レベルを一貫させる。高レベルの処理（ビジネスロジック）と低レベルの処理（ファイルI/O、文字列操作など）を同じ関数内に混在させない。

#### 名前と責務の一致

クラス/インターフェース/関数の名前は、その責務を正確に表現する。名前が示唆する範囲を超える責務を持たせない。

##### 漏れやすい抽象化の防止

抽象的な名前を付けた場合、実装詳細がインターフェースに漏れ出さないようにする：

| 問題             | 例                                                        |
| ---------------- | --------------------------------------------------------- |
| 名前より狭い責務 | `IDataProvider` が HTTP 固有の URL パラメータを要求       |
| 名前より広い責務 | `IFileReader` がファイル変換やキャッシュも担当            |
| 実装詳細の漏出   | `IAssetDownloader` が HTTP ヘッダー由来の情報を結果に含む |

##### 対処方法

- 名前を具体的にする（例: `IAssetDownloader` → `IUrlAssetDownloader`）
- 責務を分離する（追加の責務は別インターフェースに切り出す）

#### 設計判断の文書化

SOLID原則に基づく設計判断は、該当クラス/関数のコメントに「なぜその設計にしたか」を簡潔に記載する。

### 実装の一貫性

#### 既存パターンの踏襲

新規実装時は、既存コードのパターンを分析し、一貫性のあるアーキテクチャを厳守する。

#### 変更時の整合性維持

実装アプローチが変更された場合は、変数名・コメント・ログメッセージを一貫して更新する。
